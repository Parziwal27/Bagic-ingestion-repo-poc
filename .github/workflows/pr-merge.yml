name: PR Merge on Approval

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

concurrency:
  group: pr-merge-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

env:
  # allow-list of base branches (edit as needed; not hard-coded to prod)
  ALLOWED_BASES: prod
  # merge method: squash | merge | rebase
  MERGE_METHOD: squash
  # the required check name to wait for (job name from the other workflow)
  REQUIRED_CHECK: PR Quality Gate (pylint) / qa-pylint
  # how long to wait for the check to turn green after approval
  WAIT_FOR_CHECK_MINUTES: "20"

jobs:
  merge-when-approved:
    runs-on: [self-hosted, Linux, X64]
    steps:
      - name: Merge after approval & green checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // NOTE: core, github, context are provided by github-script@v7
            const pr = context.payload.pull_request;
            if (!pr) { core.info('No pull_request in payload.'); return; }
            if (pr.draft) { core.info('PR is draft, skipping.'); return; }

            // Only act on allowed base branches
            const allowed = (process.env.ALLOWED_BASES || '')
              .split(',').map(s => s.trim()).filter(Boolean);
            if (allowed.length && !allowed.includes(pr.base.ref)) {
              core.info(`Base '${pr.base.ref}' not in allow-list: ${allowed.join(', ')}`);
              return;
            }

            // Only merge if approved (on review event) or already approved (on target event)
            const { owner, repo } = context.repo;
            const q = await github.graphql(`
              query($o:String!, $n:String!, $num:Int!){
                repository(owner:$o, name:$n){
                  pullRequest(number:$num){ id number headRefOid reviewDecision }
                }
              }`,
              { o: owner, n: repo, num: pr.number }
            );
            const decision = q.repository?.pullRequest?.reviewDecision || 'UNKNOWN';
            if (decision !== 'APPROVED') {
              core.info(`reviewDecision=${decision}. Not merging yet.`);
              return;
            }

            // Wait for required check on the current head SHA
            const requiredCheck = process.env.REQUIRED_CHECK || 'PR Quality Gate (pylint) / qa-pylint';
            const waitMinutes = parseInt(process.env.WAIT_FOR_CHECK_MINUTES || '20', 10);
            const deadline = Date.now() + waitMinutes * 60 * 1000;
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            let ok = false, last = 'unknown';
            while (Date.now() < deadline) {
              // Use combined status + checks to be robust
              const checks = await github.rest.checks.listForRef({
                owner, repo, ref: pr.head.sha, per_page: 100
              });
              const run = checks.data.check_runs.find(cr => cr.name === requiredCheck
                || cr.name === 'qa-pylint'   // fallback if you ever rename workflow
                || cr.name.endsWith('/ qa-pylint'));
              if (run) {
                last = `${run.name}: ${run.status}/${run.conclusion || 'none'}`;
                if (run.status === 'completed') {
                  if (run.conclusion === 'success') { ok = true; break; }
                  core.setFailed(`Required check failed: ${last}`);
                  return;
                }
              } else {
                last = 'not found';
              }
              await sleep(15000);
            }
            if (!ok) {
              core.setFailed(`Timeout waiting for '${requiredCheck}' to succeed (last: ${last}).`);
              return;
            }

            // Merge
            try {
              const res = await github.rest.pulls.merge({
                owner, repo, pull_number: pr.number,
                merge_method: (process.env.MERGE_METHOD || 'squash').toLowerCase()
              });
              core.notice(`Merged PR #${pr.number} into '${pr.base.ref}'. Merge SHA: ${res.data.sha}`);
            } catch (e) {
              core.setFailed(`Merge failed: ${e.message}`);
            }

