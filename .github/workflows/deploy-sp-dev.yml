name: Snowflake Deploy (dev - changed SQL only)
on:
  push:
    branches: [ develop ]
    paths:
      - "SQL_DIR/**/*.sql"
      - ".github/workflows/dev-snowflake-deploy.yml"

env:
  ENV: dev
  SQL_ROOT: SQL_DIR

jobs:
  deploy:
    runs-on: [self-hosted, Linux, X64] # change to ubuntu-latest if you prefer
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure SnowSQL
        run: |
          set -euo pipefail

          if command -v snowsql >/dev/null 2>&1; then
            echo "SnowSQL already available on runner:"
            snowsql --version
            exit 0
          fi

          if [[ -z "${SNOWSQL_INSTALLER_URI:-}" ]]; then
            echo "SnowSQL is not installed on this runner and SNOWSQL_INSTALLER_URI is not configured." >&2
            echo "Install SnowSQL on the runner manually or provide an installer URI (e.g., S3 path)." >&2
            exit 1
          fi

          echo "Downloading SnowSQL installer from ${SNOWSQL_INSTALLER_URI}"
          aws s3 cp "${SNOWSQL_INSTALLER_URI}" snowsql.rpm
          if [[ ! -s snowsql.rpm ]]; then
            echo "Failed to download SnowSQL installer from ${SNOWSQL_INSTALLER_URI}" >&2
            exit 1
          fi

          sudo rpm -Uvh --replacepkgs snowsql.rpm
          echo "$HOME/.snowsql/bin" >> $GITHUB_PATH
          snowsql --version
          rm -f snowsql.rpm

      - name: Export Snowflake creds from GitHub Secrets (DEV)
        run: |
          echo "SNOWFLAKE_ACCOUNT=${{ secrets.SNOWFLAKE_ACCOUNT_DEV }}" >> $GITHUB_ENV
          echo "SNOWFLAKE_USERNAME=${{ secrets.SNOWFLAKE_USERNAME_DEV }}" >> $GITHUB_ENV
          echo "SNOWFLAKE_ROLE=${{ secrets.SNOWFLAKE_ROLE_DEV }}" >> $GITHUB_ENV
          echo "SNOWFLAKE_WAREHOUSE=${{ secrets.SNOWFLAKE_WAREHOUSE_DEV }}" >> $GITHUB_ENV
          echo "SNOWFLAKE_DATABASE=${{ secrets.SNOWFLAKE_DATABASE_DEV }}" >> $GITHUB_ENV # e.g., DEV_DB
          echo "SNOWFLAKE_SCHEMA=${{ secrets.SNOWFLAKE_SCHEMA_DEV }}" >> $GITHUB_ENV # e.g., APP
          echo "SNOWFLAKE_PRIVATE_KEY_URI=${{ secrets.SNOWFLAKE_PRIVATE_KEY_URI_DEV }}" >> $GITHUB_ENV
          echo "SNOWFLAKE_PRIVATE_KEY_PASSPHRASE=${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSPHRASE_DEV }}" >> $GITHUB_ENV
          echo "SNOWSQL_INSTALLER_URI=${{ secrets.SNOWSQL_INSTALLER_URI }}" >> $GITHUB_ENV

      - name: Download Snowflake private key from S3
        run: |
          set -euo pipefail
          if [[ -z "${SNOWFLAKE_PRIVATE_KEY_URI:-}" ]]; then
            echo "SNOWFLAKE_PRIVATE_KEY_URI secret is not configured" >&2
            exit 1
          fi
          aws s3 cp "$SNOWFLAKE_PRIVATE_KEY_URI" snowflake_rsa_key.p8
          chmod 600 snowflake_rsa_key.p8
          if grep -q "ENCRYPTED" snowflake_rsa_key.p8 && [[ -z "${SNOWFLAKE_PRIVATE_KEY_PASSPHRASE:-}" ]]; then
            echo "The downloaded Snowflake private key is encrypted but SNOWFLAKE_PRIVATE_KEY_PASSPHRASE_DEV is empty." >&2
            echo "Please set the passphrase secret or provide an unencrypted PKCS8 key." >&2
            exit 1
          fi
          echo "SNOWFLAKE_PRIVATE_KEY_PATH=${PWD}/snowflake_rsa_key.p8" >> $GITHUB_ENV

      - name: List changed SQL files (range or single commit)
        id: diff
        shell: bash
        run: |
          set -euo pipefail
          
          if [[ -n "${{ github.event.before }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
            range="${{ github.event.before }}..${{ github.sha }}"
            pathspec=":(glob)${SQL_ROOT%/}/**/*.sql"
            CHANGED=$(git diff --name-only --diff-filter=ACMR "$range" -- "$pathspec")
          else
            # First push on branch or no 'before' SHA: check this commit only
            pathspec=":(glob)${SQL_ROOT%/}/**/*.sql"
            CHANGED=$(git diff-tree --no-commit-id --name-only -r "${GITHUB_SHA}" -- "$pathspec")
          fi
          
          printf "%s\n" "$CHANGED" > changed_files.txt
          CHANGED="${CHANGED//$'\n'/ }"
          echo "changed=${CHANGED}" >> "$GITHUB_OUTPUT"
          echo "Changed SQL:"
          cat changed_files.txt || true

      - name: Build deploy.sql snapshot
        if: ${{ steps.diff.outputs.changed != '' }}
        shell: bash
        run: |
          set -euo pipefail
          : > deploy.sql
          echo "-- env: ${ENV}" >> deploy.sql
          echo "USE ROLE ${SNOWFLAKE_ROLE};" >> deploy.sql
          echo "USE WAREHOUSE ${SNOWFLAKE_WAREHOUSE};" >> deploy.sql
          echo "USE DATABASE ${SNOWFLAKE_DATABASE};" >> deploy.sql
          echo "USE SCHEMA ${SNOWFLAKE_SCHEMA};" >> deploy.sql
          echo "-- Files deployed via snowsql" >> deploy.sql
          for f in ${{ steps.diff.outputs.changed }}; do
            rel="$f"
            {
              echo ""
              echo "-- file: ${rel}"
              cat "$rel"
              echo ""
            } >> deploy.sql
          done
          
          echo "----- deploy.sql -----"
          sed -n '1,200p' deploy.sql

      - name: Validate SQL environment references
        if: ${{ steps.diff.outputs.changed != '' }}
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
import os
import pathlib
import re
import sys

changed_path = pathlib.Path("changed_files.txt")
if not changed_path.exists():
    print("No changed_files.txt found; skipping validation.")
    sys.exit(0)

database = os.environ.get("SNOWFLAKE_DATABASE", "").strip()
schema = os.environ.get("SNOWFLAKE_SCHEMA", "").strip()
if not database or not schema:
    print("SNOWFLAKE_DATABASE or SNOWFLAKE_SCHEMA missing from environment.", file=sys.stderr)
    sys.exit(1)
database_upper = database.upper()
schema_upper = schema.upper()

violations = []
blocked_tokens = {"DEV_DB", "UAT_DB", "PROD_DB"}

def normalize(identifier: str) -> str:
    identifier = identifier.strip()
    if identifier.startswith('"') and identifier.endswith('"'):
        identifier = identifier[1:-1]
    return identifier.upper()

with changed_path.open() as fh:
    files = [line.strip() for line in fh if line.strip()]

for rel_path in files:
    path = pathlib.Path(rel_path)
    if not path.exists():
        # File might be deleted; skip
        continue
    try:
        content = path.read_text()
    except UnicodeDecodeError:
        # Skip binary or non-text files
        continue

    # Check USE DATABASE / USE SCHEMA statements
    for match in re.finditer(r'(?is)\bUSE\s+DATABASE\s+([A-Z0-9_"]+)', content):
        target = normalize(match.group(1))
        if target != database_upper:
            line_no = content.count("\n", 0, match.start()) + 1
            violations.append(f"{rel_path}:{line_no} uses database '{target}' (expected {database_upper})")
    for match in re.finditer(r'(?is)\bUSE\s+SCHEMA\s+([A-Z0-9_.\"]+)', content):
        target_full = match.group(1)
        # Schema may be provided as DB.SCHEMA
        parts = [normalize(p) for p in re.split(r'\.', target_full)]
        if len(parts) == 2:
            db_part, schema_part = parts
        else:
            db_part, schema_part = database_upper, parts[0]
        if db_part != database_upper or schema_part != schema_upper:
            line_no = content.count("\n", 0, match.start()) + 1
            violations.append(f"{rel_path}:{line_no} uses schema '{target_full}' (expected {database_upper}.{schema_upper})")

    # Check fully-qualified object references other than the allowed database
    for line_no, line in enumerate(content.splitlines(), 1):
        for match in re.finditer(r'\b([A-Z0-9_]+)\.([A-Z0-9_]+)\.([A-Z0-9_]+)\b', line, flags=re.IGNORECASE):
            db_ref = normalize(match.group(1))
            if db_ref != database_upper:
                violations.append(f"{rel_path}:{line_no} references database '{db_ref}' in object '{match.group(0)}'")

    # Check for blocked tokens anywhere in the file (case-insensitive)
    upper_content = content.upper()
    for token in blocked_tokens:
        if token in upper_content:
            line_no = 1
            for ln, line in enumerate(content.splitlines(), 1):
                if token in line.upper():
                    line_no = ln
                    break
            violations.append(f"{rel_path}:{line_no} contains blocked token '{token}'")

if violations:
    print("❌ Hard-coded database/schema references detected:")
    for v in violations:
        print(f" - {v}")
    print("\nUpdate the SQL to rely on the pipeline-provided database/schema or confirm references with the data team.", file=sys.stderr)
    sys.exit(1)

print("✅ SQL files passed environment reference validation.")
PY

      - name: Exit early (no changed SQL)
        if: ${{ steps.diff.outputs.changed == '' }}
        run: echo "No SQL changes under ${SQL_ROOT}; nothing to deploy."

      - name: Execute deployment in Snowflake (continue on individual failures)
        if: ${{ steps.diff.outputs.changed != '' }}
        shell: bash {0}
        env:
          SNS_TOPIC_ARN: arn:aws:sns:ap-south-1:660061364911:datahub-notifications-sns-topic
        run: |
          set -euo pipefail

          snowsql_base=(
            snowsql
            -a "$SNOWFLAKE_ACCOUNT"
            -u "$SNOWFLAKE_USERNAME"
            -r "$SNOWFLAKE_ROLE"
            -w "$SNOWFLAKE_WAREHOUSE"
            -d "$SNOWFLAKE_DATABASE"
            -s "$SNOWFLAKE_SCHEMA"
            --private-key-path "$SNOWFLAKE_PRIVATE_KEY_PATH"
            -o exit_on_error=true
            -o friendly=false
            -o output_format=tsv
            -o timing=false
          )
          if [[ -n "${SNOWFLAKE_PRIVATE_KEY_PASSPHRASE:-}" ]]; then
            snowsql_base+=(--private-key-passphrase "$SNOWFLAKE_PRIVATE_KEY_PASSPHRASE")
          fi

          echo "Testing Snowflake connection..."
          "${snowsql_base[@]}" -q "SELECT CURRENT_USER(), CURRENT_ROLE(), CURRENT_DATABASE(), CURRENT_SCHEMA();"

          echo "Setting session context..."
          "${snowsql_base[@]}" -q "USE ROLE ${SNOWFLAKE_ROLE}; USE WAREHOUSE ${SNOWFLAKE_WAREHOUSE}; USE DATABASE ${SNOWFLAKE_DATABASE}; USE SCHEMA ${SNOWFLAKE_SCHEMA};"

          successes=()
          failures=()
          : > snow_exec_detail.log

          # Run each changed SQL file individually with snowsql
          while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            rel="${f#./}" # keep SQL_DIR/ in place; only strip leading ./ if any

            echo "---- Executing file: ${rel}" | tee -a snow_exec_detail.log

            if out=$("${snowsql_base[@]}" -f "$rel" 2>&1); then
              successes+=("$rel")
              echo "SUCCESS: ${out}" >> snow_exec_detail.log
            else
              failures+=("$rel")
              err_first_line="$(printf '%s\n' "$out" | head -n 1)"
              echo "ERROR for ${rel}: ${err_first_line}" | tee -a snow_exec_detail.log
              echo "Full error output: $out" >> snow_exec_detail.log
            fi
            echo >> snow_exec_detail.log
          done < changed_files.txt
          echo "__SUMMARY__" >> snow_exec_detail.log
          echo "SUCCESS_COUNT=${#successes[@]}" >> snow_exec_detail.log
          echo "FAIL_COUNT=${#failures[@]}" >> snow_exec_detail.log

          ok_count=${#successes[@]}
          fail_count=${#failures[@]}
          subject="Snowflake deploy (${ENV}) ✔ ${ok_count} ok / ✖ ${fail_count} failed"

          {
            echo "Environment: ${ENV}"
            echo "Database.Schema: ${SNOWFLAKE_DATABASE}.${SNOWFLAKE_SCHEMA}"
            echo "Warehouse: ${SNOWFLAKE_WAREHOUSE}"
            echo
            echo "✅ SUCCEEDED (${ok_count}):"
            if (( ok_count > 0 )); then
              printf ' - %s\n' "${successes[@]}"
            else
              echo "  - (none)"
            fi
            echo
            echo "❌ FAILED (${fail_count}):"
            if (( fail_count > 0 )); then
              printf ' - %s\n' "${failures[@]}"
            else
              echo "  - (none)"
            fi
            echo
            echo "Detail log attached below."
            echo
            echo "===== DETAIL ====="
            cat snow_exec_detail.log
          } > sns_message.txt

          aws sns publish \
            --topic-arn "$SNS_TOPIC_ARN" \
            --subject "$subject" \
            --message file://sns_message.txt

          echo "Execution completed. Summary:"
          echo "✅ Succeeded: ${ok_count} files"
          echo "❌ Failed: ${fail_count} files"

          if (( fail_count > 0 )); then
            echo "⚠️  Some SQL files failed to execute. Check the detailed logs for more information."
            echo "Failed files: ${failures[*]}"
            exit 1
          fi

      - name: Upload deploy.sql artifact
        if: ${{ steps.diff.outputs.changed != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: dev-deploy-sql
          path: deploy.sql

      - name: Upload execution detail log
        if: ${{ steps.diff.outputs.changed != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: snowflake-exec-detail
          path: snow_exec_detail.log
